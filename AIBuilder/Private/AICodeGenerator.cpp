// AICodeGenerator.cpp - AI Assistant Implementation
#include "AICodeGenerator.h"
#include "HAL/FileManager.h"
#include "Misc/FileHelper.h"
#include "Misc/Paths.h"
#include "AIBuilder.h"

UAICodeGenerator::UAICodeGenerator()
{
    Initialize();
}

void UAICodeGenerator::Initialize()
{
    InitializeTemplates();
    InitializeAIKeywords();
    InitializeCodeSnippets();
    
    UE_LOG(LogAICodeGen, Log, TEXT("AI Code Generator initialized with templates and keywords"));
}

FGeneratedCode UAICodeGenerator::GenerateCodeFromRequest(const FString& UserRequest)
{
    UE_LOG(LogAICodeGen, Log, TEXT("Processing user request: %s"), *UserRequest);
    
    FGeneratedCode Result;
    
    // Parse the user request
    FCodeRequest ParsedRequest = ParseUserRequest(UserRequest);
    
    if (ParsedRequest.ClassName.IsEmpty())
    {
        Result.bSuccess = false;
        Result.ErrorMessage = TEXT("Could not determine class name from request");
        return Result;
    }
    
    // Generate header and source code
    Result.HeaderCode = GenerateHeaderTemplate(ParsedRequest);
    Result.SourceCode = GenerateSourceTemplate(ParsedRequest);
    Result.FileName = ParsedRequest.ClassName;
    Result.bSuccess = ValidateGeneratedCode(Result.HeaderCode) && ValidateGeneratedCode(Result.SourceCode);
    
    if (!Result.bSuccess)
    {
        Result.ErrorMessage = TEXT("Generated code failed validation");
    }
    
    UE_LOG(LogAICodeGen, Log, TEXT("Code generation %s for class %s"), 
           Result.bSuccess ? TEXT("succeeded") : TEXT("failed"), 
           *ParsedRequest.ClassName);
    
    return Result;
}

FGeneratedCode UAICodeGenerator::CreateAICharacter(const FString& CharacterName, const FString& BehaviorDescription)
{
    FGeneratedCode Result;
    
    FString HeaderCode = FString::Printf(TEXT(R"(
// %s.h - AI Character generated by AI Code Generator
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "AIController.h"
#include "BehaviorTree/BehaviorTreeComponent.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "Perception/AIPerceptionComponent.h"
#include "%s.generated.h"

UCLASS(BlueprintType, Blueprintable)
class AIBUILDER_API A%s : public ACharacter
{
    GENERATED_BODY()

public:
    A%s();

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;

    // AI Components
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI")
    class UAIPerceptionComponent* AIPerceptionComponent;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI")
    class UBehaviorTreeComponent* BehaviorTreeComponent;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI")
    class UBlackboardComponent* BlackboardComponent;

    // AI Configuration
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AI")
    class UBehaviorTree* BehaviorTree;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AI")
    class UBlackboardAsset* BlackboardAsset;

public:
    // Blueprint callable functions for %s
    UFUNCTION(BlueprintCallable, Category = "AI")
    void StartAI();

    UFUNCTION(BlueprintCallable, Category = "AI")
    void StopAI();

    UFUNCTION(BlueprintCallable, Category = "AI")
    void SetTarget(AActor* NewTarget);

private:
    void InitializeAI();
    void SetupPerception();
};
)"), *CharacterName, *CharacterName, *CharacterName, *CharacterName, *BehaviorDescription);

    FString SourceCode = FString::Printf(TEXT(R"(
// %s.cpp - AI Character implementation
#include "%s.h"
#include "AIController.h"
#include "BehaviorTree/BehaviorTree.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "Perception/AISenseConfig_Sight.h"

A%s::A%s()
{
    PrimaryActorTick.bCanEverTick = true;

    // Initialize AI components
    AIPerceptionComponent = CreateDefaultSubobject<UAIPerceptionComponent>(TEXT("AIPerceptionComponent"));
    BehaviorTreeComponent = CreateDefaultSubobject<UBehaviorTreeComponent>(TEXT("BehaviorTreeComponent"));
    BlackboardComponent = CreateDefaultSubobject<UBlackboardComponent>(TEXT("BlackboardComponent"));
}

void A%s::BeginPlay()
{
    Super::BeginPlay();
    InitializeAI();
}

void A%s::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    // Custom AI behavior for %s
}

void A%s::InitializeAI()
{
    if (AAIController* AIController = Cast<AAIController>(GetController()))
    {
        if (BlackboardAsset)
        {
            AIController->UseBlackboard(BlackboardAsset);
        }
        
        SetupPerception();
        StartAI();
    }
}

void A%s::SetupPerception()
{
    if (AIPerceptionComponent)
    {
        UAISenseConfig_Sight* SightConfig = CreateDefaultSubobject<UAISenseConfig_Sight>(TEXT("SightConfig"));
        SightConfig->SightRadius = 1500.0f;
        SightConfig->LoseSightRadius = 1600.0f;
        SightConfig->PeripheralVisionAngleDegrees = 90.0f;
        
        AIPerceptionComponent->ConfigureSense(*SightConfig);
        AIPerceptionComponent->SetDominantSense(SightConfig->GetSenseImplementation());
    }
}

void A%s::StartAI()
{
    if (AAIController* AIController = Cast<AAIController>(GetController()))
    {
        if (BehaviorTree)
        {
            AIController->RunBehaviorTree(BehaviorTree);
        }
    }
}

void A%s::StopAI()
{
    if (AAIController* AIController = Cast<AAIController>(GetController()))
    {
        AIController->StopBehaviorTree(EBTStopMode::Safe);
    }
}

void A%s::SetTarget(AActor* NewTarget)
{
    if (BlackboardComponent)
    {
        BlackboardComponent->SetValueAsObject(TEXT("TargetActor"), NewTarget);
    }
}
)"), *CharacterName, *CharacterName, *CharacterName, *CharacterName, *CharacterName, *CharacterName, *BehaviorDescription, *CharacterName, *CharacterName, *CharacterName, *CharacterName, *CharacterName);

    Result.HeaderCode = HeaderCode;
    Result.SourceCode = SourceCode;
    Result.FileName = CharacterName;
    Result.bSuccess = true;
    
    return Result;
}

FGeneratedCode UAICodeGenerator::CreateBehaviorTreeTask(const FString& TaskName, const FString& TaskDescription)
{
    FGeneratedCode Result;
    
    FString HeaderCode = FString::Printf(TEXT(R"(
// %s.h - Behavior Tree Task generated by AI Code Generator
#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/BTTaskNode.h"
#include "%s.generated.h"

UCLASS()
class AIBUILDER_API U%s : public UBTTaskNode
{
    GENERATED_BODY()

public:
    U%s();

    virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;
    virtual FString GetStaticDescription() const override;

protected:
    // Task parameters for %s
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Task")
    float TaskDuration = 1.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Task")
    bool bRequiresTarget = false;

private:
    bool ExecuteTaskLogic(UBehaviorTreeComponent& OwnerComp);
};
)"), *TaskName, *TaskName, *TaskName, *TaskName, *TaskDescription);

    FString SourceCode = FString::Printf(TEXT(R"(
// %s.cpp - Behavior Tree Task implementation
#include "%s.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "AIController.h"

U%s::U%s()
{
    NodeName = TEXT("%s");
    bNotifyTick = true;
}

EBTNodeResult::Type U%s::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
    if (ExecuteTaskLogic(OwnerComp))
    {
        return EBTNodeResult::Succeeded;
    }
    
    return EBTNodeResult::Failed;
}

FString U%s::GetStaticDescription() const
{
    return FString::Printf(TEXT("%s: %s"), *Super::GetStaticDescription(), TEXT("%s"));
}

bool U%s::ExecuteTaskLogic(UBehaviorTreeComponent& OwnerComp)
{
    AAIController* AIController = OwnerComp.GetAIOwner();
    if (!AIController)
    {
        return false;
    }

    APawn* ControlledPawn = AIController->GetPawn();
    if (!ControlledPawn)
    {
        return false;
    }

    // Custom task logic for %s
    // TODO: Implement specific behavior based on task description
    
    return true;
}
)"), *TaskName, *TaskName, *TaskName, *TaskName, *TaskName, *TaskName, *TaskName, *TaskDescription, *TaskName, *TaskDescription);

    Result.HeaderCode = HeaderCode;
    Result.SourceCode = SourceCode;
    Result.FileName = TaskName;
    Result.bSuccess = true;
    
    return Result;
}

FCodeRequest UAICodeGenerator::ParseUserRequest(const FString& UserRequest)
{
    FCodeRequest Request;
    Request.UserRequest = UserRequest;
    
    // Extract class name
    Request.ClassName = ExtractClassName(UserRequest);
    
    // Determine base class
    Request.BaseClass = DetermineBaseClass(UserRequest);
    
    // Extract features
    TArray<FString> Features = ExtractRequiredFeatures(UserRequest);
    Request.Functions = Features;
    
    return Request;
}

FString UAICodeGenerator::ExtractClassName(const FString& Request)
{
    // Simple pattern matching for class names
    FString LowerRequest = Request.ToLower();
    
    if (LowerRequest.Contains(TEXT("character")) || LowerRequest.Contains(TEXT("ai character")))
    {
        // Extract name before "character"
        int32 CharacterIndex = LowerRequest.Find(TEXT("character"));
        if (CharacterIndex > 0)
        {
            FString NamePart = Request.Left(CharacterIndex).TrimEnd();
            TArray<FString> Words;
            NamePart.ParseIntoArray(Words, TEXT(" "));
            if (Words.Num() > 0)
            {
                return CapitalizeFirstLetter(Words.Last()) + TEXT("Character");
            }
        }
        return TEXT("AICharacter");
    }
    
    if (LowerRequest.Contains(TEXT("controller")))
    {
        return TEXT("AIController");
    }
    
    if (LowerRequest.Contains(TEXT("task")))
    {
        return TEXT("BTTask");
    }
    
    return TEXT("GeneratedClass");
}

FString UAICodeGenerator::DetermineBaseClass(const FString& Request)
{
    FString LowerRequest = Request.ToLower();
    
    if (LowerRequest.Contains(TEXT("character")))
        return TEXT("ACharacter");
    if (LowerRequest.Contains(TEXT("controller")))
        return TEXT("AAIController");
    if (LowerRequest.Contains(TEXT("task")))
        return TEXT("UBTTaskNode");
    if (LowerRequest.Contains(TEXT("component")))
        return TEXT("UActorComponent");
    
    return TEXT("UObject");
}

void UAICodeGenerator::InitializeTemplates()
{
    // Initialize code templates
    HeaderTemplates.Add(TEXT("Character"), TEXT("ACharacter header template"));
    HeaderTemplates.Add(TEXT("Controller"), TEXT("AAIController header template"));
    HeaderTemplates.Add(TEXT("Task"), TEXT("UBTTaskNode header template"));
    
    SourceTemplates.Add(TEXT("Character"), TEXT("ACharacter source template"));
    SourceTemplates.Add(TEXT("Controller"), TEXT("AAIController source template"));
    SourceTemplates.Add(TEXT("Task"), TEXT("UBTTaskNode source template"));
}

void UAICodeGenerator::InitializeAIKeywords()
{
    AIKeywords.Add(TEXT("patrol"), TEXT("PatrolBehavior"));
    AIKeywords.Add(TEXT("chase"), TEXT("ChaseBehavior"));
    AIKeywords.Add(TEXT("attack"), TEXT("AttackBehavior"));
    AIKeywords.Add(TEXT("guard"), TEXT("GuardBehavior"));
    AIKeywords.Add(TEXT("follow"), TEXT("FollowBehavior"));
}

FString UAICodeGenerator::GenerateHeaderTemplate(const FCodeRequest& Request)
{
    // Generate basic header template
    return FString::Printf(TEXT("// Generated header for %s"), *Request.ClassName);
}

FString UAICodeGenerator::GenerateSourceTemplate(const FCodeRequest& Request)
{
    // Generate basic source template
    return FString::Printf(TEXT("// Generated source for %s"), *Request.ClassName);
}

bool UAICodeGenerator::ValidateGeneratedCode(const FString& Code)
{
    // Basic validation - check for required elements
    return !Code.IsEmpty() && Code.Contains(TEXT("class")) && Code.Contains(TEXT("GENERATED_BODY"));
}

FString UAICodeGenerator::CapitalizeFirstLetter(const FString& Input)
{
    if (Input.IsEmpty())
        return Input;
    
    return Input.Left(1).ToUpper() + Input.Mid(1).ToLower();
}

void UAICodeGenerator::SaveGeneratedCode(const FGeneratedCode& Code, const FString& OutputPath)
{
    if (!Code.bSuccess)
    {
        UE_LOG(LogAICodeGen, Error, TEXT("Cannot save failed code generation"));
        return;
    }
    
    FString HeaderPath = FPaths::Combine(OutputPath, Code.FileName + TEXT(".h"));
    FString SourcePath = FPaths::Combine(OutputPath, Code.FileName + TEXT(".cpp"));
    
    FFileHelper::SaveStringToFile(Code.HeaderCode, *HeaderPath);
    FFileHelper::SaveStringToFile(Code.SourceCode, *SourcePath);
    
    UE_LOG(LogAICodeGen, Log, TEXT("Saved generated code to %s"), *OutputPath);
}

TArray<FString> UAICodeGenerator::GetAvailableTemplates() const
{
    TArray<FString> Templates;
    HeaderTemplates.GetKeys(Templates);
    return Templates;
}

// Placeholder implementations for remaining functions
TArray<FString> UAICodeGenerator::ExtractRequiredFeatures(const FString& Request) { return TArray<FString>(); }
void UAICodeGenerator::InitializeCodeSnippets() {}
FGeneratedCode UAICodeGenerator::CreateAIController(const FString& ControllerName, const FString& ControllerType) { return FGeneratedCode(); }
FGeneratedCode UAICodeGenerator::CreateAIComponent(const FString& ComponentName, const FString& ComponentPurpose) { return FGeneratedCode(); }
FString UAICodeGenerator::GenerateClassDeclaration(const FCodeRequest& Request) { return TEXT(""); }
FString UAICodeGenerator::GenerateConstructor(const FCodeRequest& Request) { return TEXT(""); }
FString UAICodeGenerator::GenerateFunctions(const FCodeRequest& Request) { return TEXT(""); }
FString UAICodeGenerator::GenerateProperties(const FCodeRequest& Request) { return TEXT(""); }
FString UAICodeGenerator::GenerateAICharacterCode(const FString& CharacterName, const FString& BehaviorDescription) { return TEXT(""); }
FString UAICodeGenerator::GenerateAIControllerCode(const FString& ControllerName, const FString& ControllerType) { return TEXT(""); }
FString UAICodeGenerator::GenerateBehaviorTreeTaskCode(const FString& TaskName, const FString& TaskDescription) { return TEXT(""); }
FString UAICodeGenerator::GenerateAIComponentCode(const FString& ComponentName, const FString& ComponentPurpose) { return TEXT(""); }
FString UAICodeGenerator::FormatCode(const FString& Code) { return Code; }
FString UAICodeGenerator::AddIncludes(const TArray<FString>& Includes) { return TEXT(""); }
FString UAICodeGenerator::AddNamespaces() { return TEXT(""); }
FString UAICodeGenerator::ReplaceTemplateVariables(const FString& Template, const FCodeRequest& Request) { return Template; }
bool UAICodeGenerator::ContainsKeyword(const FString& Text, const FString& Keyword) { return Text.Contains(Keyword); }
FString UAICodeGenerator::GenerateUniqueClassName(const FString& BaseName) { return BaseName; }